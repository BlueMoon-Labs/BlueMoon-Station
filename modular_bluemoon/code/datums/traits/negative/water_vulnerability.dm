/datum/quirk/water_vulnerability
	name = BLUEMOON_TRAIT_NAME_WATER_VULNERABILITY
	desc = "ТОЛЬКО ДЛЯ СИНТЕТИКОВ! Ваш корпус недостаточно хорошо изолирует ваши внутренние компоненты от влаги, так что попадание на него воды может привести к неприятностям. Принимать обычный душ и купаться в бассейне противопоказано - стоит захватить мыло или спрей с очистителем!"
	value = -2
	gain_text = span_danger("Надеюсь, меня никто не уронит в воду...")
	lose_text = span_notice("\"Водонепроницаемость\" - моё второе имя! Где мои плавки? Время для пляжного эпизода!")
	on_spawn_immediate = FALSE // иначе on_spawn из-за потенциального удаления квирка ломается
	mob_trait = TRAIT_BLUEMOON_WATER_VULNERABILITY

/datum/quirk/water_vulnerability/on_spawn()
	. = ..()
	if(!isrobotic(quirk_holder))
		to_chat(quirk_holder, span_warning("Все квирки были сброшены, т.к. квирк [src] не подходит виду персонажа."))
		var/list/user_quirks = quirk_holder.roundstart_quirks
		user_quirks -= src
		for(var/datum/quirk/Q as anything in user_quirks)
			qdel(Q)
		qdel(src)

/datum/quirk/water_vulnerability/add()
	RegisterSignal(quirk_holder, COMSIG_ATOM_EXPOSE_REAGENTS, PROC_REF(handle_reagents))

/datum/quirk/water_vulnerability/remove()
	UnregisterSignal(quirk_holder, COMSIG_ATOM_EXPOSE_REAGENTS)

/datum/quirk/water_vulnerability/proc/handle_reagents(atom/source, list/reagents, datum/reagents/source_reagents, methods, volume_modifier, show_message, from_gas)
	SIGNAL_HANDLER

	if(!reagents.len)
		return
	if(!ishuman(quirk_holder))
		return
	var/mob/living/carbon/human/H = quirk_holder
	if(!(methods == VAPOR || methods == PATCH || methods == TOUCH))
		return
	if (H.wear_suit && H.head && istype(H.wear_suit, /obj/item/clothing) && istype(H.head, /obj/item/clothing))
		var/obj/item/clothing/worn_suit = H.wear_suit
		var/obj/item/clothing/worn_helmet = H.head
		if (worn_suit.clothing_flags & worn_helmet.clothing_flags & THICKMATERIAL)
			return

	// Можно было бы вместо простой воды поставить список токопроводящих реагентов, но это был бы overkill
	var/datum/reagent/water/moisture = locate() in reagents
	if(!moisture || prob(clamp(40 - moisture.volume, 5, 40)))
		return
	switch(rand(1,10))
		if(1 to 3)
			to_chat(H, span_warning("Пара капель воды попадает под ваш корпус! Аккуратнее!"))
			do_fake_sparks(2, TRUE, H)
		if(3 to 6)
			H.visible_message(span_warning("[H] вздрагивает, испуская сноп искр после попадания влаги на [H.ru_ego()] корпус!"), span_boldwarning("Несколько ваших актюаторов замыкает из-за попавшей под корпус влаги!"))
			do_sparks(3, TRUE, H)
			H.Confused(7)
			H.Jitter(7)
			// Почему не apply_damage? Потому что это SIGNAL_HANDLER, который не может спать, а именно этим и занимается plug13
			// при вызове apply_damage. Мы живём в обществе.
			H.take_overall_damage(0, 15)
		if(6 to 9)
			H.visible_message(span_warning("[H] падает на землю, когда [H.ru_ego()] схемы замыкает попавшая влага!"), span_boldwarning("Влага замыкает ваши схемы!"))
			do_sparks(4, TRUE, H)
			H.Knockdown(20)
			H.Confused(15)
			H.Jitter(15)
			H.take_overall_damage(0, 30)
		if(10)
			H.visible_message(span_boldwarning("[H] с громким шипением падает на землю и выключается, искря и дымясь после попадания воды на [H.ru_ego()] микросхемы!"), span_alertsyndie("// ОБНАРУЖЕНО ВОЗГОРАНИЕ \n// ПОТЕРЯНО СОЕДИНЕНИЕ С 94% СИСТЕМ. \n // ПЕРЕЗАГРУЗКА..."))
			do_sparks(5, TRUE, H)
			H.Jitter(20)
			H.AdjustUnconscious(70)
			H.adjustToxLoss(20, toxins_type = TOX_SYSCORRUPT)
			H.take_overall_damage(0, 40)
			playsound(H, 'sound/machines/hiss.ogg', 40, FALSE)
			playsound(H, 'modular_splurt/sound/misc/connection_terminated.ogg', 40, FALSE)





